#include <QPainter>
#include <QtGlobal>
#include <QtDebug>
#include <iostream>
#include "common/ViajeAlCentroDeLaTierraScr.h"
#include "screen.h"
#include "zx48k_rom.h"
#include "common/clock.h"
#include "common/hardware/zxhardwaremodel48k.h"

int scale = 2;

Screen::Screen(QWidget *parent) : QWidget(parent)
{
    antiAliased = false;
    setBackgroundRole(QPalette::Base);
    setAutoFillBackground(true);
    bcmFrameBuffer = new CBcmFrameBuffer(352, 272, 4);
    m_zxDisplay.Initialize(ViajeAlCentroDeLaTierra_scr, bcmFrameBuffer);
    m_model = new ZxHardwareModel48k();
    Clock::getInstance().setSpectrumModel(m_model);
}


QSize Screen::minimumSizeHint() const
{
    return QSize(scale * 352 /* 48 + 256 + 48 */, scale * 272 /*(32 + 192 + 48)*/);
}

QSize Screen::sizeHint() const
{
    return QSize(scale * 352 /* 48 + 256 + 48 */, scale * 272 /*(32 + 192 + 48)*/);
}

// A small block or character may be generated by eight binary numbers. Such a block of 8 by 8 pixels is known as a
// character block. The Spectrum has three types of characters built in: the 96 character standard set, the 16
// character block graphics set and the 21 character user-defined graphics set. The latter two sets are accessed from
// the keyboard in graphics mode. These characters are placed on the display when PRINT is used.
//
// references:
// - [Character Graphics on the ZX Spectrum](https://link.springer.com/chapter/10.1007/978-1-349-06763-3_6)
// - [ZX Basic Manual. CHAPTER 14: The Character Set](https://www.worldofspectrum.org/ZXBasicManual/zxmanchap14.html)
void printText(uint8_t *buffer, unsigned int column, unsigned int row, uint8_t ink, uint8_t paper, char const *text) {

    static uint8_t characters[0x90 * 0x08];
    const unsigned int charsetAddr = 0x3D00;

    for (unsigned int g = 0x00; g < 0x80; g++) {
        for (unsigned int idx = 0x00; idx < 0x08; idx++) {
            characters[g * 0x08 + idx] = zx48k_rom[charsetAddr + g * 8 + idx];
        }
    }

    const uint8_t ROWFILL[] = {0x00, 0x0F, 0xF0, 0xFF};

    // The graphics characters are not stored in ROM but are instead calculated from the character code where each bit
    // of the lower 4 bits in the byte represents a corner in the target block character in the following order:
    // bottom-left, bottom, right, top-left, top-right (1 0 0 0 BL BR TL TR)
    for (unsigned int g = 0x80; g < 0x90; g++) {
//        std::cout << std::hex << "// " << std::hex << g << std::endl;
        for (unsigned int idx = 0x00; idx < 0x08; idx++) {
            characters[g * 0x08 + idx] = ROWFILL[(idx < 0x04) ? (g & 0x03u) : ((g & 0x0Cu) >> 0x02u)];
//            std::cout << std::hex << static_cast<unsigned int>(ROWFILL[(g & 0x0Cu) >> ((idx < 0x04) ? 0x00u : 0x02u)]) << std::endl;
        }
    }

    uint8_t foreground = ink;
    uint8_t background = paper;

    // possible combinations of 2 pixels stored in a single byte as a group of 2 elements of 4 bits.
    uint8_t twinColouredPixels[] = {
            static_cast<uint8_t>(static_cast<uint8_t>(background << 0x4u) | background),
            static_cast<uint8_t>(static_cast<uint8_t>(background << 0x4u) | foreground),
            static_cast<uint8_t>(static_cast<uint8_t>(foreground << 0x4u) | background),
            static_cast<uint8_t>(static_cast<uint8_t>(foreground << 0x4u) | foreground)
    };

    auto const *c = reinterpret_cast<unsigned char const *>(text);
    do {
//        std::cout << std::hex << static_cast<unsigned int>(*c) << " ";
        unsigned int rowOffset = row * 8 * 176;

        for (unsigned int line=0x00; line < 0x08; line++) {
//            uint8_t charLine = zx48k_rom[charsetAddr + ((*c - 0x20) * 8) + line];
            uint8_t charLine = characters[((*c - 0x20u) * 0x08) + line];
//            std::bitset<8> cl(charLine);
//            std::cout << std::hex << line << " " << cl.to_string(' ', 'X') << std::endl;
//            qDebug() << line << x.to_string();
//            uint8_t charLine = zx48k_rom[charsetAddr + ((*c) * 8) + line];
//
//            std::cout << std::hex << line << " ";

            uint8_t mask = 0xC0;
            for (unsigned int x = 0; x < 4; x++) {
                uint8_t bits = charLine & mask;
                mask = mask >> 0x02u;
//                std::cout << "(" << (8 - x * 2) << ")";
//                std::cout << "(" << bits << ")";
//                std::cout << ((bits == 0) ? " " : "@");
                buffer[rowOffset + column * 4 + x + line * 176] = twinColouredPixels[bits >> (6 - x * 2)];
            }
//            std::cout << std::endl;
        }
        if (++column >= 44) {
            column = 0;
            row++;
        }

    } while (*(++c) != '\0');

}

void drawFrame(uint8_t *buffer, unsigned int x, unsigned int y, unsigned int width, unsigned int height) {
    char line[44 + 1] = "\xAF\xAF About ZX Raspberry \xAB";
//    char line[44 + 1] = "\xAB\xA3\xAA\xAF\xA5\xA3 About ZX Raspberry ";
//    char line[44 + 1] = { '\xAB', '\xA7' };
    for (unsigned int x1 = strlen(line); x1 < width; x1++)
        line[x1] = '\xA3';
    line[width - 1] = '\xA7';
//        line[x1] = '\xA3';
//    line[width - 1] = '\xA7';
    line[width] = 0x00;
    ::printText(buffer, x, y, 0x0, 0xF, reinterpret_cast<char const *>(line));
//    ::printText(buffer, x + width - 1, y, 0x0, 0xF, "\xA7");

    char line2[44 + 1] = "\xAE";
    for (unsigned int x1 = strlen(line2); x1 < width; x1++)
        line2[x1] = '\xAC';
    line2[width - 1] = '\xAD';
    line2[width] = 0x00;
    ::printText(buffer, x, y + height - 1, 0x0, 0xF, line2);

    for (unsigned y1 = y + 1; y1 < height - 1; y1++) {
        ::printText(buffer, x, y1, 0x0, 0xF, "\xAA");
        ::printText(buffer, x + width - 1, y1, 0x0, 0xF, "\xA5");
    }
}

void Screen::paintEvent(QPaintEvent * /* event */)
{
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing, antiAliased);
    painter.save();
    m_zxDisplay.update(false);

    QByteArray videoMemory = QByteArray::fromRawData((const char *) bcmFrameBuffer->GetBuffer(), bcmFrameBuffer->GetSize());

    /*
     * The default printable characters (32 (space) to 127 (copyright)) are stored at the end of the Spectrum's ROM at
     * memory address 15616 (0x3D00) to 16383 (0x3FFF) and are referenced by the system variable CHARS which can be
     * found at memory address 23606/7. Interestingly, the value in CHARS is actually 256 bytes lower than the first
     * byte of the space character so that referencing a printable ASCII character does not need to consider the first
     * 32 characters. As such, the CHARS value (by default) holds the address 15360 (0x3C00).
     *
     * The UDG characters (Gr-A to Gr-U) are stored at the end of the Spectrum's RAM at memory address 65368 (0xFF58)
     * to 65535 (0xFFFF). As such, POKEing this address range has immediate effect on the UDG characters. The USR
     * keyword (when followed by a single quoted character) provides a quick method to reference these addresses from
     * BASIC. As with the printable characters, the location of the UDG characters is stored in the system variable UDG.
     *
     * Reference: https://enacademic.com/dic.nsf/enwiki/513468
     */
    char const *version = "ZX Raspberry Ver. " __DATE__ " " __TIME__;
    ::printText(reinterpret_cast<uint8_t *>(bcmFrameBuffer->GetBuffer()), 1, 1, 0x0, 0xF, version);
    char const *copyright = "Copyright \x7F 2020-2023 Jose Hernandez";
    ::printText(reinterpret_cast<uint8_t *>(bcmFrameBuffer->GetBuffer()), 1, 2, 0x4, 0xF, copyright);

    ::printText(reinterpret_cast<uint8_t *>(bcmFrameBuffer->GetBuffer()), 1, 30, 0xD, 0x0, "SCREEN DIMENSIONS:");
    char const *innerDimensions = "Inner: 32*24 chars (256 x 192 pixels)";
    ::printText(reinterpret_cast<uint8_t *>(bcmFrameBuffer->GetBuffer()), 1, 31, 0xC, 0x0, innerDimensions);
    char const *outerDimensions = "Outer: 44*34 chars (352 x 272 pixels)";
    ::printText(reinterpret_cast<uint8_t *>(bcmFrameBuffer->GetBuffer()), 1, 32, 0xE, 0x0, outerDimensions);

    drawFrame(reinterpret_cast<uint8_t *>(bcmFrameBuffer->GetBuffer()), 0, 0, 44, 34);

    for (unsigned int y = 0; y < 34; y++) {
        char rowNum[10] = {};
        snprintf(rowNum, 10, "%02d", y);
        ::printText(reinterpret_cast<uint8_t *>(bcmFrameBuffer->GetBuffer()), 41, y, 0xD, 0x0, rowNum);
    }

    /* Reads Raspberry Pi framebuffer and turns it into a QImage object.
     *
     * Image data in the framebuffer is stored linearly starting with pixel (0,0) on the top left and the moving right
     * and down one pixel at a time.  In our particular example we have 2 pixels per byte and the bytes are out of
     * sequence because they are stored as a single 32 bit unsigned integer instead of 4 individual bytes.
     */
#if BYTE_SWAP_DISABLED
    for (int i = 0; i < 272; i++) {
        for (int j = 0; j < 44; j++) {
            for (int k=0; k<4; k++) {
                uint8_t byte = videoMemory.at( (i * 176) + (j * 4) + (3 - k) );
                raspberryPiImage.setPixel( (j * 8) + (k * 2), i, m_pBcmFrameBuffer->palette[(byte & 0xF0) >> 4] );
                raspberryPiImage.setPixel( (j * 8) + (k * 2) + 1 , i, m_pBcmFrameBuffer->palette[byte & 0x0F] );
            }
        }
    }
#else
    for (int i = 0x0000; i < 0x0110; i++) {
        for (int j = 0x0000; j < 0x00B0; j++) {
            uint8_t byte = reinterpret_cast<char *>(bcmFrameBuffer->GetBuffer())[(i * 0x00B0) + j];
            raspberryPiImage.setPixel((j * 2), i, bcmFrameBuffer->palette[(byte & 0xF0u) >> 0x04u]);
            raspberryPiImage.setPixel((j * 2) + 1, i, bcmFrameBuffer->palette[byte & 0x0Fu]);
        }
    }
#endif

    /* In theory, the main screen should have a border of 48 pixels on the left,
     * 48 on the right, 48 on top and 56 pixels at the bottom but the ZX Spectrum
     * bare emulator only seems to have a 32 pixel border at the top and a 48
     * pixel border at the bottom.
     * 
     * The left margin also appers to be smaller than the right margin on the
     * Raspeberry Pi.
     * 
     * http://www.zxdesign.info/vidparam.shtml
     */
    painter.drawImage(QRect(0, 0, 352 * scale, 272 * scale), raspberryPiImage);

    painter.restore();
    painter.setRenderHint(QPainter::Antialiasing, false);
    painter.setPen(palette().dark().color());
}
