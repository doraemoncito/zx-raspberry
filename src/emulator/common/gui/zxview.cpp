/*
 * Copyright (c) 2020-2023 Jose Hernandez
 *
 * This file is part of ZxRaspberry.
 *
 * ZxRaspberry is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ZxRaspberry is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ZxRaspberry.  If not, see <https://www.gnu.org/licenses/>.
 */
#include "zxdialog.h"
#include "zx48k_rom.h"
#include <cstdio>
#include <cstring>
#include <cstdint>
#include "zxview.h"


uint8_t ZxView::characters[0x90 * 0x08];

/*
 * Renders an expanded version of the character set for easy drawing of UI elements.
 */
ZxView::ZxView(ZxRect const &bounds) : m_parent(nullptr), m_bounds(bounds) {

    /*
     * The first 128 (0x80) characters in the ZX Spectrum character set are stored as 8 byte bit patters each
     * representing an 8 by 8 character.
     */
    for (unsigned int g = 0x00; g < 0x80; g++) {
        for (unsigned int idx = 0x00; idx < 0x08; idx++) {
            characters[g * 0x08 + idx] = zx48k_rom[charsetAddr + g * 8 + idx];
        }
    }

    // Lookup table representing the 4 possible states a row in a character block graphic can be in
    const uint8_t rowFillTable[] = {0x00, 0x0F, 0xF0, 0xFF};

    /*
     * The graphics characters are not stored in ROM but are instead calculated from the character code where each bit
     * of the lower 4 bits in the byte represents a corner in the target block character in the following order:
     *
     *      bottom-left, bottom, right, top-left, top-right.
     *
     *  BYTE: 1 0 0 0 BL BR TL TR
     */
    for (unsigned int g = 0x80; g < 0x90; g++) {
        for (unsigned int idx = 0x00; idx < 0x08; idx++) {
            characters[g * 0x08 + idx] = rowFillTable[(idx < 0x04) ? (g & 0x03u) : ((g & 0x0Cu) >> 0x02u)];
        }
    }
}

void ZxView::clear(uint8_t *buffer, uint8_t paper) {

    uint8_t background = paper;

    // Combination of 2 pixels stored in a single byte as a group of 2 elements of 4 bits representing the paper colour.
    auto twinColouredPixel = static_cast<uint8_t>(static_cast<uint8_t>(background << 0x4u) | background);

    auto parent = this->parent();
    ZxRect bounds;
    if (nullptr != parent) {
        bounds = parent->bounds();
        bounds.grow(-1, -1);
    } else {
        bounds = {0, 0, 44, 37};
    }

    bounds = this->m_bounds;

    for (int row = bounds.getAx(); row < bounds.getAx() + bounds.getHeight(); row++) {
        for (int column = bounds.getAx(); column < bounds.getAx() + bounds.getWidth(); column++) {
            unsigned int rowOffset = row * 8 * 176;

            for (unsigned int line = 0x00; line < 0x08; line++) {
                /*
                 * A character is 8 pixels wide and since we are drawing two pixels at a time we only have to repeat
                 * the operations 4 times.
                 */
                for (unsigned int x = 0; x < 4; x++) {
                    buffer[rowOffset + column * 4 + x + line * 176] = twinColouredPixel;
                }
            }
        }
    }
}

/*
 * A small block or character may be generated by eight binary numbers. Such a block of 8 by 8 pixels is known as a
 * character block. The Spectrum has three types of characters built in: the 96 character standard set, the 16
 * character block graphics set and the 21 character user-defined graphics set. The latter two sets are accessed from
 * the keyboard in graphics mode. These characters are placed on the display when PRINT is used.
 *
 * references:
 * - [Character Graphics on the ZX Spectrum](https://link.springer.com/chapter/10.1007/978-1-349-06763-3_6)
 * - [ZX Basic Manual. CHAPTER 14: The Character Set](https://www.worldofspectrum.org/ZXBasicManual/zxmanchap14.html)
 */
void ZxView::printText(uint8_t *buffer, unsigned int column, unsigned int row, uint8_t ink, uint8_t paper, char const *text) const {

    auto parent = this->parent();
    ZxRect bounds;
    if (nullptr != parent) {
        bounds = parent->bounds();
        bounds.grow(-1 , -1);
    } else {
        bounds = { 0, 0, 44, 37};
    }
    column += bounds.getAx();
    row += bounds.getAy();

    uint8_t foreground = ink;
    uint8_t background = paper;

    // possible combinations of 2 pixels stored in a single byte as a group of 2 elements of 4 bits.
    uint8_t twinColouredPixels[] = {
            static_cast<uint8_t>(static_cast<uint8_t>(background << 0x4u) | background),
            static_cast<uint8_t>(static_cast<uint8_t>(background << 0x4u) | foreground),
            static_cast<uint8_t>(static_cast<uint8_t>(foreground << 0x4u) | background),
            static_cast<uint8_t>(static_cast<uint8_t>(foreground << 0x4u) | foreground)
    };

    auto const *c = reinterpret_cast<unsigned char const *>(text);
    do {
        unsigned int rowOffset = row * 8 * 176;

        for (unsigned int line=0x00; line < 0x08; line++) {
            uint8_t charLine = ZxDialog::characters[((*c - 0x20u) * 0x08) + line];
//            std::bitset<8> cl(charLine);
//            std::cout << std::hex << line << " " << cl.to_string(' ', 'X') << std::endl;
//            qDebug() << line << x.to_string();
//            uint8_t charLine = zx48k_rom[charsetAddr + ((*c) * 8) + line];

            uint8_t mask = 0xC0;
            for (unsigned int x = 0; x < 4; x++) {
                uint8_t bits = charLine & mask;
                mask = mask >> 0x02u;
                buffer[rowOffset + column * 4 + x + line * 176] = twinColouredPixels[bits >> (6 - x * 2)];
            }
        }
        if (++column >= 44) {
            column = 0;
            row++;
        }

    } while (*(++c) != '\0');
}

ZxView::~ZxView() {
    if (m_parent != nullptr) {
        // TODO: make call to remove this view from its parent
        m_parent = nullptr;
    }
}

ZxView *ZxView::parent() const {
    return m_parent;
}

void ZxView::setParent(ZxView *parent) {
    m_parent = parent;
}

ZxRect const &ZxView::bounds() const {
    return m_bounds;
}
